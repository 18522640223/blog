---
title: 面试题总结
date: 2016-12-30
tags:
 - javaScript
categories: 
 - javaScript
---

希望坚持下去，每天总结一点点。。重在积累

## 手写发布订阅模式

``` js{1}
  // 发布订阅模式
  class EventEmitter {
    constructor() {
      // 事件对象，用于存储事件订阅的名字和事件 列： {click: [handel, handel]}
      this.event = {}
    }
    // 首先订阅事件
    on(eventName, callBack) {
      if(!this.event[eventName]) {
        // 一个名称也可以订阅多个事件
        this.event[eventName] = [callBack]
      } else {
        // 否则就要push进去
        this.event[eventName].push(callBack)
      }
    }
    // 然后触发事件
    emit(eventName, ...arg) {
      // 遍历所有的事件
      this.event[eventName] && this.event[eventName].forEach(fn => {
        fn.apply(this, arg)
      })
    }
    // 移除事件
    remove(eventName, callBack) {
      if(callBack) {
        this.event[eventName].splice(callBack, 1)
      }else {
        delete this.event[eventName]
      }
    }
  }
  export default EventEmitter


  // 使用

  let event = new EventEmitter()

  event.on('click', handle)
  event.emit('click', 12212)
  event.remove('click', handle)
```
## React高阶函数的写法，一般有几种

第一种是通过工厂模式直接 wrapper，第二种是通过组件反向继承的方式

``` js{2}
class A extend B {
  render () {
    return (
      <div> component1 start </div>
      super.render()
      <div> component1 end </div>
    )
  }
}
```
## 尽可能写出更多的数的方法。
splice、push、pop、shift、unshift，sort、fill、reverse。
## JS中的this
1.在函数使用new关键字调用的时候，this是一个全新的对象。</br>
2.如果是call，apply，bind调用或者是创建一个函数是，函数的this是作为参数传过来的放大的对象。</br>
3.如果是一个对象里的方法被调用的时候，那么this就是调用这个方法的对象。</br>
4.还有一种就是都不是上述的那么this就是指向的window，也就是全局对象。如果在严格模式下就是undefined。

## 节流函数
  节流函数是指在触发事件后，一定事件间隔内无法连续调用，只有过了这段时间才能进行下次进行调用。
  注意事项：
    第一次立即执行
    每间隔一段时间执行一次
    在间隔时间内的触发，需要在间隔末尾执行一次
  ```js{3}
  function throttle (callback, timeout) {
    var lastTimeout = 0
    var throttleId
    return function (...arg) {
      var now = +new Date()
      var remaining = now - lastTimeout
      if(remaining > timeout) {
        if(throttleId) {
          clearTimeout(throttleId)
        }
        callback.apply(this, arg)
      }else if(!throttleId) {
        throttleId = setTimeout(() =>{
          callback.apply(this, arg)
          throttleId = null
        }, timeout-remaining)
      }
    }
  }
  ```
  ## 防抖函数
  防抖函数时指在函数多次被出发后，只执行一次，并且在出发结束后执行。
  注意点：
    this 指向
    event 对象
    立刻执行

  ```js{4}
  function debounce (fn, delay) {
    let timer
    return function (...arg) {
      if (timer) {
        clearTimeout(timer)
      }
      timer = setTimeout(()=>{
        fn.apply(this, arg)
      }, delay)
    }
  }
  ```
  ## arguments
  arguments是数组么？怎么实现让arguments有数组的方法，有长度么？类数组和数组的区别是什么？

  1，arguments不是数组，但是有length属性。无法使用数组的方法。</br>
  2，可以转化为数组，因为有Symbol(Symbol.iterator())方法。</br>
  3，可以使用以下方法，将含有Symbol(Symbol.iterator())属性的对象，转化成数组。</br>
  ```js{5}
  [...arguments]
  Array.prototype.slice.call(arguments)
  Array.from(arguments)
  ```
  4，类数组是一个对象，typeof 判断出来就不一致。

## 模拟实现call，apply，bind
分析三个方法的作用：
  1，改变this的指向，</br>
  2，传入参数，</br>
  3，call，apply直接返回结果，bind返回一个函数</br>

首先我们知道对象上的方法在调用时候，this指向这个对象
```js{6}
  var obj = {
    fun:function() {
      console.log(this)
    }
  }
  obj.fun() //Object {fn: function}
```
知道了这点我们就可以改变this的指向了
```js{6}
Function.prototype.myCall = function(obj) {
  //给obj添加一个函数属性，
  obj._fn_ = this
  obj._fn_() //在obj上调用函数，那函数的this值就是obj
  delete obj._fn_  //再删除_fn_属性
}
//用ES6实现
Function.prototype.myCall = function(obj, ...arg) {
  obj._fn_ = this
  obj._fn_(...arg)
  delete obj._fn_  //再删除_fn_属性
}
Function.prototype.myCall = function(context) {
  let context = context || window
  context.fn = this
  let arg = [...argument].slice(1)
  let re = context.fn(...arg)
  delete context.fn
  return re
}
``` 
实现apply apply接受的参数是个数组 实现起来和call 大同小异

```js{6}
Function.prototype.myCall = function(context, arr) {
  let context = context || window
  let args = []
  arr.forEach(fn => {
    args.push(fn)
  })
  context.fn = this
  let res = context.fn(...args)
  delete context.fn
  return res 
}
``` 
bind思路也是一样的只不过bind 返回的不是一个结果是个函数

```js{6}
Function.prototype.Bind = function(context) {
  // 首先我们要判断this是否是一个函数
  if (typeof this !== 'function') {
    throw new TypeError('error')
  }
  var _this = this
  var args = [...arguments].slice(1)
  return function F() {
    // 疑问返回是个函数我们，我们可以new F(),所以我们要判断
    if (this instanceof F) {
      return new _this(...arg,...arguments )
    }
    return _this.apply(context, args.concat(...arguments))
  }
}
``` 

